**大家好，我是老刘**

老刘做Flutter开发差不多7年了，期间，跨平台的观望者最爱问：

> “为啥选Flutter？”
> “Flutter凉了怎么办？”

而初学Flutter开发的同学最爱问：

> “有没有那种拿来就能用的 Flutter 脚手架？”

## 1. 那个进群先问“有没有脚手架”的新手，后来怎么样了？

前段时间，群里钻进来个新手。

进群第一句话就问：“各位大佬，有没有那种拿来就能用的 Flutter 脚手架？”

“最好是集成好状态管理、网络请求、持久化存储、各种 Utils 全家桶的那种。”

看着他那急切的口吻，我仿佛看到了几年前还没被社会毒打过的自己。

有不少资深的开发马上就开始劝他放弃找脚手架的想法了。

为什么很多老手对“脚手架”这种提速神器表现得如此警惕？

因为在真正的实战派眼里，这种对“全家桶”的追求，往往是灾难的开始。

很多新手找脚手架，表面上是为了“不重复造轮子”，提高开发效率。

实际上，这种心态在潜意识里是在逃避对 Flutter 原生逻辑的深度思考。

他们希望跳过繁琐的架构选型，跳过对 Widget 生命周期与状态流转的磨合，直接快进到“写业务逻辑”。

也许是因为新手对未知领域的恐惧，也许紧张的开发周期对牛马造成的时间上的稀缺感。

但这种逃避，最终都会变成加倍偿还的技术债。

那个问脚手架的新手，在用某款热门模板开发了三个月后，又回来找我了。

他们团队把之前用的脚手架都给扔掉了，加了两周的班重构代码。

这时候也许他才明白，有些“捷径”，其实是通往深渊的最短路径。

![](https://blog.zegocloud.com/wp-content/uploads/2024/02/programming-meme-2.jpg)

---

## 2. 解析：为什么说Flutter的“脚手架”是初学者的温柔陷阱？

很多人对 Flutter 有个深深的误解。

觉得它像 Web 开发那样，非得整一个类似 `vue、react` 这种大而全的脚手架才敢动手写代码。

但事实上，Flutter 本身就是一个巨大的、高度集成的“脚手架”。

当你运行 `flutter create`，并在代码里引入 `material.dart` 的那一刻。

Google 已经把路由管理、UI 主题、动画引擎、甚至多端适配的基础底座全给你铺好了。

在这样一个本身就极度现代化的框架之上，再去层层套叠一个第三方的“全家桶脚手架”。

往往不是在提效，而是在做**过度封装**。

下面详细说说过度使用脚手架的几个弊端：

#### 首先，它剥夺了你作为开发者的深度思考

市面上那些动辄集成了状态管理、网络请求、本地缓存、权限管理等几十个功能的重度脚手架。

为了追求所谓的“一键开工”，通常会把所有的原生 API 封装成一套高度私有的语法。

你以为自己在学习 Flutter 开发，其实你只是在学习那个脚手架作者的个人代码癖好。

这就好比你还没学会走路，就先给自己装了一副电动外骨骼。

初期确实健步如飞，可一旦业务逻辑超出了外骨骼的支撑范围。

![](https://laoliu-blog.oss-cn-beijing.aliyuncs.com/img/20260115154941047.png)

或者你想换个姿势走，你会尴尬地发现自己连站都站不稳。

#### 其次，它在项目初期就埋下了技术债

这种全家桶脚手架往往是“强耦合”的重灾区。

作者为了显得功能全面，会塞进大量他认为好用的第三方插件。

在项目的“蜜月期”，你确实省去了查文档、做技术选型的时间。

可一旦 Flutter SDK 迎来重大更新，或者脚手架里某个核心插件停止维护了。

整个项目就会瞬间陷入瘫痪。

你想升级一个插件，可能得重构半个项目的底层架构。

这种“请神容易送神难”的痛苦，只有在项目进入维护期时，你才会深刻体会到。

#### 第三，这种思维违背了一个软件开发的通用原则：**组合胜过封装**

Flutter 鼓励我们用原子化的 Widget 去灵活拼装复杂的业务场景。

而不是用一套沉重的、预定义的“标准模版”去套所有的需求。

真正的架构能力，绝不是能熟练使用某种脚手架。

而是当你面对一个新的需求时，能根据业务规模和团队现状。

精准地挑选出最合适的路由方案、状态管理工具，并用最简洁的逻辑把它们串联起来。


#### 最后，还有一个在 AI 时代被很多人忽略的致命伤：**大部分重度脚手架对 AI 是不友好的**

现在大家写代码，谁还离得开 Cursor、Claude 或者 Copilot？

这些 AI 模型的“大脑”，是基于海量的开源代码和官方文档训练出来的。

它们最擅长的是标准的 Flutter 语法、标准的组件用法，以及社区公认的主流库（如 Provider、Riverpod、Dio）。

当你使用一套高度定制化的脚手架时，你实际上是把自己关进了一个“信息孤岛”。

AI 根本不知道你那个脚手架作者自己封装的 `BaseController` 怎么用。

也不知道定义的 `EasyRequest` 到底有哪些参数。

结果就是，当你试图让 AI 帮你写一段业务逻辑时。

它给出的代码往往会因为不符合你脚手架的私有规范而报错。

你不得不花大量的时间去人工纠偏，甚至要亲手重写。

在 AI 辅助编程的今天，**“标准”就是效率，“原生”就是生产力。**

![](https://laoliu-blog.oss-cn-beijing.aliyuncs.com/img/20260115154507348.png)

坚持使用官方推荐的模式和社区主流的组合方案，能让 AI 的生成准确率提升好几个量级。

---

## 3. 解决方案：如何优雅地“手搓”一套属于自己的开发流？

既然“全家桶”是坑，那我们该怎么搞？

答案很简单：**回归原生，按需组装。**

你要做的不是去找一个现成的“毛坯房”，而是学会自己当架构师。

**第一步：如非必要勿增实体**

永远不要在项目还没开始的时候，就先往 `pubspec.yaml` 里塞几十个插件。

每一个引入的包，都应该是为了解决当下的具体痛点，而不是为了“万一以后用到”。

这种克制，是保持代码洁净的第一步。

**第二步：像搭积木一样，挑选Flutter社区公认的“原子化”工具。**

![](https://laoliu-blog.oss-cn-beijing.aliyuncs.com/img/20260115154829441.png)

网络请求？直接上 `Dio`。

它是 Flutter 社区的绝对标准，文档齐全。

AI 对它的各种拦截器、配置项了如指掌。

状态管理？选 `Provider` 或者 `Bloc`。

别去搞那些小众的、自创的逻辑框架。

因为当你遇到问题时，Google 搜索和 Claude 能给你最精准的解答。

路由管理？Flutter原生的 `Navigator` 对大多数项目足够了。

它能完美处理嵌套路由和深层链接。

关键是它的配置逻辑非常清晰，不会让项目变成一团乱麻。

**第三步：建立一套基于“约定”而非“限制”的简单规范。**

比如统一的 `Button` 或 `AppLoading`。

与其花三个月去填第三方脚手架的坑，不如花三天时间整理出一套属于自己的 `utils` 工具集。（不关你是独立开发者还是团队，这套工具集都能用于你的多个项目）

这种基于约定的开发流，就像是给代码留白。

当你需要接入一个新的功能模块时，你发现自己是在“写代码”，而不是在“填空题”。

最重要的是，当你把这套干净、标准的代码丢给 Cursor 时。

你会惊喜地发现，AI 写的代码甚至比你自己写的还要优雅。

因为它不需要去猜你那些奇奇怪怪的封装。

它只需要按照最标准的 Flutter 逻辑输出就行了。

---

## 4. 总结：最好的脚手架，是你的代码规范

很多开发者觉得，不用脚手架会降低开发速度。

但如果你算上后期的维护成本、升级成本，以及和 AI 磨合的沟通成本。

你会发现，“手搓”才是真正的捷径。

脚手架能带你走完前 100 米，但只有原生的设计哲学能带你走完剩下的 99 公里。

框架应该是用来解决问题的，而不是用来限制你想象力的。

一个优秀的开发者，不应该是一个熟练的“模板搬运工”。

而应该是一个能看透业务本质，并能用最简单的工具解决最复杂问题的匠人。

脚手架能给你临时的安全感，但只有对底层逻辑的掌控，才能给你长久的职业尊严。

别让那些大而全的模板，阉割了你的思考能力。

当你能优雅地“手搓”出一套开发流时，你才算真正推开了 Flutter 进阶的大门。

当然老刘也非常理解对于很多初学者来说，凭空搭建一个完整的App是一个比较大的挑战。

因此老刘的实战课程和书籍里面也用专门的章节来讲解了如何搭建一个App的基础框架。

后续老刘会把这部分内容整理到文章里面，帮大家搭建一个App的基础框架，包括路由管理、状态管理等等。

初学者可以先从这个基础框架开始，通过增加自己的页面、组件和业务逻辑，逐步搭建起自己的App。

---

> 如果看到这里的同学对客户端开发或者Flutter开发感兴趣，欢迎联系老刘，我们互相学习。
>
> 点击免费领老刘整理的《Flutter开发手册》，覆盖90%应用开发场景。
>
> 可以作为Flutter学习的知识地图。
>
> [覆盖90%开发场景的《Flutter开发手册》](https://mp.weixin.qq.com/s?__biz=MzkxMDMzNTM0Mw==&mid=2247483665&idx=1&sn=56aec9504da3ffad5797e703c12c51f6&chksm=c12c4d11f65bc40767956e534bd4b6fa71cbc2b8f8980294b6db7582672809c966e13cbbed25#rd)

